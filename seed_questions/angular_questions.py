ANGULAR_QUESTIONS = [
    # --- Tricky Concept Questions ---
    {"question_text": "What is the difference between ngOnInit() and the constructor in Angular?", "option_a": "They are identical in functionality", "option_b": "Constructor is for dependency injection; ngOnInit is for initialization logic after inputs are set", "option_c": "Constructor runs after ngOnInit", "option_d": "ngOnInit is deprecated in Angular 16+", "correct_option": "B"},
    {"question_text": "What is the output lifecycle hook order in Angular?\n\n1. ngOnChanges\n2. ngOnInit\n3. ngDoCheck\n4. ngAfterContentInit\n5. ngAfterContentChecked\n6. ngAfterViewInit\n7. ngAfterViewChecked\n8. ngOnDestroy\n\nWhich hook is called ONLY ONCE?", "option_a": "ngOnChanges", "option_b": "ngDoCheck", "option_c": "ngOnInit", "option_d": "ngAfterViewChecked", "correct_option": "C"},
    {"question_text": "What is the difference between @ViewChild and @ContentChild?", "option_a": "They are identical", "option_b": "@ViewChild queries elements in the component's template; @ContentChild queries projected content (ng-content)", "option_c": "@ViewChild is for services; @ContentChild is for components", "option_d": "@ContentChild is deprecated", "correct_option": "B"},
    {"question_text": "In Angular, what does 'changeDetection: ChangeDetectionStrategy.OnPush' do?", "option_a": "Disables change detection entirely", "option_b": "Only runs change detection when @Input references change or events are triggered in the component", "option_c": "Runs change detection on every browser event", "option_d": "Pushes changes to the server", "correct_option": "B"},
    {"question_text": "What is the output?\n\n@Component({ template: '{{ value }}' })\nexport class TestComponent {\n    value = 'initial';\n    \n    ngOnInit() {\n        setTimeout(() => this.value = 'updated', 0);\n    }\n}\n\nWhat will be displayed?", "option_a": "initial (never updates)", "option_b": "updated (after a tick)", "option_c": "initial then updated", "option_d": "ExpressionChangedAfterItHasBeenCheckedError", "correct_option": "C"},
    {"question_text": "What is Zone.js and why is it important in Angular?", "option_a": "A CSS framework used by Angular", "option_b": "A library that patches async APIs to trigger Angular's change detection automatically", "option_c": "A testing utility", "option_d": "A build tool for Angular applications", "correct_option": "B"},
    {"question_text": "What is the difference between a 'declarations' and 'imports' array in an NgModule?", "option_a": "They are the same thing", "option_b": "'declarations' lists components/directives/pipes belonging to this module; 'imports' brings in other modules", "option_c": "'imports' is for components; 'declarations' is for services", "option_d": "'declarations' imports external libraries", "correct_option": "B"},
    {"question_text": "What is the purpose of Angular's Renderer2?", "option_a": "To render 3D graphics", "option_b": "To safely manipulate DOM elements, especially for server-side rendering and web workers", "option_c": "To render templates", "option_d": "To compile TypeScript to JavaScript", "correct_option": "B"},
    {"question_text": "In Angular Reactive Forms, what is the difference between setValue() and patchValue()?", "option_a": "They are identical", "option_b": "setValue requires ALL form control values; patchValue allows partial updates", "option_c": "patchValue requires ALL values; setValue allows partial updates", "option_d": "setValue is for template-driven forms; patchValue is for reactive forms", "correct_option": "B"},
    {"question_text": "What will happen if you provide a service in both a component's providers array and the root module?", "option_a": "Error - duplicate provider", "option_b": "The component gets its own instance; other components get the root instance", "option_c": "Only the root instance is used everywhere", "option_d": "Only the component instance is used everywhere", "correct_option": "B"},
    # --- Coding Snippet Questions ---
    {"question_text": "What is wrong with this code?\n\n@Component({ selector: 'app-test', template: '<p>{{data}}</p>' })\nexport class TestComponent implements OnInit {\n    data: string;\n    \n    ngOnInit() {\n        this.http.get('/api/data').subscribe(res => this.data = res);\n    }\n}", "option_a": "Nothing is wrong", "option_b": "HttpClient is not injected via constructor", "option_c": "subscribe is deprecated", "option_d": "ngOnInit cannot be async", "correct_option": "B"},
    {"question_text": "What does this RxJS code do?\n\nthis.searchInput$.pipe(\n    debounceTime(300),\n    distinctUntilChanged(),\n    switchMap(term => this.searchService.search(term))\n).subscribe(results => this.results = results);", "option_a": "Searches immediately on every keystroke", "option_b": "Waits 300ms after typing stops, ignores duplicates, cancels previous requests", "option_c": "Searches every 300ms regardless of input", "option_d": "Caches all search results", "correct_option": "B"},
    {"question_text": "What is the output?\n\nconst subject = new BehaviorSubject<number>(0);\nsubject.next(1);\nsubject.next(2);\nsubject.subscribe(val => console.log(val));\nsubject.next(3);", "option_a": "0 1 2 3", "option_b": "1 2 3", "option_c": "2 3", "option_d": "3", "correct_option": "C"},
    {"question_text": "What is the difference between Subject, BehaviorSubject, and ReplaySubject?", "option_a": "They are all identical", "option_b": "Subject has no initial value; BehaviorSubject holds last value for new subscribers; ReplaySubject replays N values", "option_c": "Subject replays values; BehaviorSubject doesn't", "option_d": "ReplaySubject is for errors only", "correct_option": "B"},
    {"question_text": "What problem does this code have?\n\n@Component({...})\nexport class MyComponent implements OnInit {\n    ngOnInit() {\n        this.route.params.subscribe(params => {\n            this.userId = params['id'];\n            this.userService.getUser(this.userId).subscribe(user => {\n                this.user = user;\n            });\n        });\n    }\n}", "option_a": "Nothing wrong", "option_b": "Nested subscriptions (subscribe inside subscribe) - should use switchMap/mergeMap", "option_c": "route.params is not observable", "option_d": "getUser should not return observable", "correct_option": "B"},
    {"question_text": "In Angular, what does the async pipe do?\n\n<p>{{ data$ | async }}</p>", "option_a": "Makes the component asynchronous", "option_b": "Subscribes to the observable, returns the latest value, and auto-unsubscribes on destroy", "option_c": "Converts data to async format", "option_d": "Delays rendering", "correct_option": "B"},
    {"question_text": "What is the purpose of trackBy in *ngFor?\n\n<div *ngFor=\"let item of items; trackBy: trackById\">\n    {{ item.name }}\n</div>", "option_a": "Tracks user clicks on items", "option_b": "Helps Angular identify which items changed, improving performance by not re-rendering unchanged items", "option_c": "Adds analytics tracking", "option_d": "Sorts items by ID", "correct_option": "B"},
    {"question_text": "What is the output?\n\nconst obs$ = new Observable(subscriber => {\n    subscriber.next(1);\n    subscriber.next(2);\n    subscriber.complete();\n    subscriber.next(3);\n});\n\nobs$.subscribe(val => console.log(val));", "option_a": "1 2 3", "option_b": "1 2", "option_c": "1 2 3 complete", "option_d": "Error", "correct_option": "B"},
    # --- Scenario-Based Questions ---
    {"question_text": "Your Angular app has a form with 20 fields and complex validation. Which approach is BEST?", "option_a": "Template-driven forms with ngModel", "option_b": "Reactive forms with FormGroup and FormControl for better control and testability", "option_c": "Plain HTML forms with JavaScript validation", "option_d": "No validation - trust user input", "correct_option": "B"},
    {"question_text": "Your Angular component subscribes to multiple observables in ngOnInit. What is the BEST way to prevent memory leaks?", "option_a": "Don't worry about it - Angular handles cleanup", "option_b": "Use takeUntil with a destroy subject, or use the async pipe, or use takeUntilDestroyed()", "option_c": "Call subscribe() without storing the subscription", "option_d": "Use setTimeout to clear subscriptions", "correct_option": "B"},
    {"question_text": "What is lazy loading in Angular and how do you implement it?", "option_a": "Loading all modules at once for faster performance", "option_b": "Loading feature modules on demand using loadChildren in route configuration", "option_c": "Delaying component rendering with setTimeout", "option_d": "Using service workers to cache modules", "correct_option": "B"},
    {"question_text": "What is the purpose of Angular's NgZone.runOutsideAngular()?", "option_a": "Runs code outside the browser", "option_b": "Runs code without triggering change detection, useful for performance-intensive operations", "option_c": "Runs code in a web worker", "option_d": "Runs code on the server", "correct_option": "B"},
    {"question_text": "In Angular, what is the difference between providedIn: 'root' and providing a service in a module's providers array?", "option_a": "They are identical", "option_b": "providedIn: 'root' creates a singleton and is tree-shakable; module providers are not tree-shakable", "option_c": "Module providers are tree-shakable; providedIn: 'root' is not", "option_d": "providedIn: 'root' is deprecated", "correct_option": "B"},
    {"question_text": "What is the output?\n\nconst obs$ = of(1, 2, 3).pipe(\n    map(x => x * 2),\n    filter(x => x > 2),\n    tap(x => console.log('tap:', x)),\n    reduce((acc, val) => acc + val, 0)\n);\nobs$.subscribe(x => console.log('result:', x));", "option_a": "tap: 4 tap: 6 result: 10", "option_b": "result: 12", "option_c": "tap: 2 tap: 4 tap: 6 result: 12", "option_d": "tap: 4 tap: 6 result: 10", "correct_option": "A"},
    {"question_text": "What is Angular Universal used for?", "option_a": "Cross-platform mobile development", "option_b": "Server-side rendering (SSR) of Angular applications", "option_c": "Universal CSS framework", "option_d": "Internationalization (i18n)", "correct_option": "B"},
    {"question_text": "What is the difference between canActivate and canDeactivate route guards?", "option_a": "They are identical", "option_b": "canActivate prevents navigation TO a route; canDeactivate prevents navigation AWAY FROM a route", "option_c": "canActivate is for authentication; canDeactivate is for authorization", "option_d": "canDeactivate is deprecated", "correct_option": "B"},
    {"question_text": "What is the output?\n\nconst obs1$ = interval(1000).pipe(take(3));\nconst obs2$ = interval(500).pipe(take(3));\n\nforkJoin([obs1$, obs2$]).subscribe(console.log);", "option_a": "Emits every value from both observables", "option_b": "Emits only when BOTH complete, with their last values: [2, 2]", "option_c": "Emits the first value from each", "option_d": "Error", "correct_option": "B"},
    {"question_text": "What is the purpose of Angular Signals introduced in Angular 16?", "option_a": "A new HTTP client", "option_b": "A reactive primitive for fine-grained reactivity, reducing Zone.js dependency", "option_c": "A new routing system", "option_d": "A testing framework", "correct_option": "B"},
    {"question_text": "In Angular testing, what is the difference between TestBed.createComponent() and new ComponentClass()?", "option_a": "They are identical", "option_b": "TestBed creates a fully configured component with DI, template, and change detection; 'new' creates a bare instance", "option_c": "new is preferred for integration tests", "option_d": "TestBed is deprecated", "correct_option": "B"},
    {"question_text": "What does the following pipe do?\n\nobservable$.pipe(\n    catchError(err => {\n        console.error(err);\n        return of([]);\n    })\n);", "option_a": "Terminates the observable on error", "option_b": "Catches errors and replaces with an empty array, keeping the stream alive", "option_c": "Retries the request", "option_d": "Logs the error and rethrows it", "correct_option": "B"},
    {"question_text": "What is the difference between ng-content and ng-template?", "option_a": "They are identical", "option_b": "ng-content is for content projection from parent; ng-template defines reusable template blocks rendered conditionally", "option_c": "ng-template projects content; ng-content defines templates", "option_d": "Both are deprecated in favor of Angular 17 syntax", "correct_option": "B"},
    {"question_text": "What is a pure vs impure pipe in Angular?", "option_a": "Pure pipes run on every change detection cycle; impure pipes only on input changes", "option_b": "Pure pipes only run when their input value changes by reference; impure pipes run on every change detection cycle", "option_c": "They are identical in behavior", "option_d": "Impure pipes are not allowed in Angular", "correct_option": "B"},
    {"question_text": "What is the purpose of the environment.ts files in Angular?", "option_a": "To store CSS variables", "option_b": "To define environment-specific configuration (API URLs, feature flags) swapped at build time", "option_c": "To configure the Angular CLI", "option_d": "To define test data", "correct_option": "B"},
    {"question_text": "In Angular 17+, what are standalone components?", "option_a": "Components that run without a browser", "option_b": "Components that don't need to be declared in an NgModule, importing dependencies directly", "option_c": "Components without templates", "option_d": "Components that can't have services", "correct_option": "B"},
    {"question_text": "What is the output?\n\nconst subject = new AsyncSubject<number>();\nsubject.next(1);\nsubject.next(2);\nsubject.next(3);\nsubject.subscribe(val => console.log(val));\nsubject.complete();", "option_a": "1 2 3", "option_b": "3", "option_c": "Nothing (no output)", "option_d": "1", "correct_option": "B"},
    {"question_text": "What is the purpose of Angular's Dependency Injection hierarchical injector?", "option_a": "Only for providing services globally", "option_b": "Allows different parts of the app to have different instances of a service based on module/component hierarchy", "option_c": "For CSS inheritance", "option_d": "For routing hierarchy", "correct_option": "B"},
    {"question_text": "What happens when you use mergeMap vs switchMap vs concatMap for HTTP requests?", "option_a": "They all behave identically", "option_b": "mergeMap runs all concurrently; switchMap cancels previous; concatMap queues sequentially", "option_c": "switchMap runs concurrently; mergeMap cancels; concatMap errors", "option_d": "They all cancel previous requests", "correct_option": "B"},
    {"question_text": "What is the @HostListener decorator used for?", "option_a": "Listening to server events", "option_b": "Declaring an event listener on the host element of a directive or component", "option_c": "Hosting the application", "option_d": "Listening to route changes", "correct_option": "B"},
    {"question_text": "In Angular, what is the difference between a Component and a Directive?", "option_a": "They are identical", "option_b": "A Component is a Directive with a template; a Directive adds behavior to existing DOM elements", "option_c": "A Directive has a template; a Component doesn't", "option_d": "Components are deprecated in favor of Directives", "correct_option": "B"},
    {"question_text": "What is the purpose of ngOnChanges lifecycle hook?", "option_a": "Detects changes in local variables", "option_b": "Called when @Input properties change, receiving a SimpleChanges object", "option_c": "Called on every setTimeout", "option_d": "Called when user clicks", "correct_option": "B"},
    {"question_text": "What is tree-shaking in Angular and why is it important?", "option_a": "A CSS animation technique", "option_b": "Dead code elimination during build - removes unused code to reduce bundle size", "option_c": "A testing strategy", "option_d": "A rendering optimization", "correct_option": "B"},
    {"question_text": "What problem does this code have?\n\n@Component({...})\nexport class MyComponent {\n    @Input() items: string[] = [];\n    \n    get filteredItems() {\n        return this.items.filter(i => i.length > 3).sort();\n    }\n}\n\n// Template: <div *ngFor=\"let item of filteredItems\">", "option_a": "Nothing wrong", "option_b": "filteredItems getter runs on every change detection cycle, creating new arrays each time - should use a pipe or computed signal", "option_c": "filter is not available on arrays", "option_d": "*ngFor doesn't work with getters", "correct_option": "B"},
]
