NODEJS_QUESTIONS = [
    {"question_text": "What is the output?\n\nconsole.log(typeof null);\nconsole.log(typeof undefined);", "option_a": "object undefined", "option_b": "null null", "option_c": "null undefined", "option_d": "object object", "correct_option": "A"},
    {"question_text": "What is the output?\n\nconsole.log([] == ![]);\nconsole.log([] == []);", "option_a": "true true", "option_b": "true false", "option_c": "false false", "option_d": "false true", "correct_option": "B"},
    {"question_text": "What is the output?\n\nconsole.log(1 + '2' + 3);\nconsole.log(1 + 2 + '3');", "option_a": "6 and 33", "option_b": "6 and 6", "option_c": "123 and 33", "option_d": "123 and 123", "correct_option": "C"},
    {"question_text": "What is the output?\n\nconst a = {};\nconst b = { key: 'b' };\nconst c = { key: 'c' };\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);", "option_a": "undefined", "option_b": "123", "option_c": "Error", "option_d": "456", "correct_option": "D"},
    {"question_text": "In Node.js, what is the Event Loop and which phase handles setTimeout callbacks?", "option_a": "Event Loop is a single-threaded mechanism; setTimeout runs in the timers phase", "option_b": "Event Loop is multi-threaded; setTimeout runs in the poll phase", "option_c": "Event Loop is a process; setTimeout runs in the check phase", "option_d": "Event Loop is a thread pool; setTimeout runs in the I/O phase", "correct_option": "A"},
    {"question_text": "What is the output?\n\nsetImmediate(() => console.log('immediate'));\nsetTimeout(() => console.log('timeout'), 0);\nprocess.nextTick(() => console.log('nextTick'));\nconsole.log('main');", "option_a": "main nextTick immediate timeout", "option_b": "The order of timeout and immediate is non-deterministic, but main and nextTick are always first", "option_c": "main timeout immediate nextTick", "option_d": "main nextTick timeout immediate", "correct_option": "B"},
    {"question_text": "What is the output?\n\nconst promise = new Promise((resolve, reject) => {\n    console.log(1);\n    resolve();\n    console.log(2);\n});\npromise.then(() => console.log(3));\nconsole.log(4);", "option_a": "1 3 2 4", "option_b": "4 1 2 3", "option_c": "1 2 4 3", "option_d": "1 2 3 4", "correct_option": "C"},
    {"question_text": "What does 'use strict' do in JavaScript?", "option_a": "Enables TypeScript features", "option_b": "Enables async/await syntax", "option_c": "Makes code run faster", "option_d": "Catches common coding mistakes, prevents unsafe actions, disables some features", "correct_option": "D"},
    {"question_text": "What is the output?\n\nconst obj = { a: 1, b: 2, c: 3 };\nconst { a, ...rest } = obj;\nconsole.log(rest);", "option_a": "{ b: 2, c: 3 }", "option_b": "[2, 3]", "option_c": "Error", "option_d": "{ a: 1, b: 2, c: 3 }", "correct_option": "A"},
    {"question_text": "What is the output?\n\nlet x = 1;\nlet y = x;\nx = 2;\nconsole.log(y);\n\nlet a = { val: 1 };\nlet b = a;\na.val = 2;\nconsole.log(b.val);", "option_a": "1 and 1", "option_b": "1 and 2", "option_c": "2 and 2", "option_d": "2 and 1", "correct_option": "B"},
    {"question_text": "What is the output?\n\nconst arr = [1, 2, 3, 4, 5];\nconst result = arr.reduce((acc, cur) => {\n    if (cur % 2 === 0) acc.push(cur * 2);\n    return acc;\n}, []);\nconsole.log(result);", "option_a": "[1, 4, 3, 8, 5]", "option_b": "[2, 6, 10]", "option_c": "[4, 8]", "option_d": "[2, 4, 6, 8, 10]", "correct_option": "C"},
    {"question_text": "What is the output?\n\nasync function foo() {\n    const p1 = fetch('/api/1');\n    const p2 = fetch('/api/2');\n    const [r1, r2] = await Promise.all([p1, p2]);\n    return [r1, r2];\n}\n\nWhat advantage does this have over sequential awaits?", "option_a": "It uses less memory", "option_b": "No advantage - they behave the same", "option_c": "It catches errors better", "option_d": "Both requests run in parallel, reducing total wait time", "correct_option": "D"},
    {"question_text": "What is the output?\n\nfunction createCounter() {\n    let count = 0;\n    return {\n        increment: () => ++count,\n        getCount: () => count\n    };\n}\n\nconst counter = createCounter();\ncounter.increment();\ncounter.increment();\nconsole.log(counter.getCount());", "option_a": "2", "option_b": "1", "option_c": "Error", "option_d": "0", "correct_option": "A"},
    {"question_text": "What is the output?\n\nconst map = new Map();\nmap.set('1', 'str');\nmap.set(1, 'num');\nmap.set(true, 'bool');\n\nconsole.log(map.get('1'));\nconsole.log(map.get(1));\nconsole.log(map.size);", "option_a": "str str 2", "option_b": "str num 3", "option_c": "num num 3", "option_d": "bool bool 1", "correct_option": "B"},
    {"question_text": "What is the output?\n\nfor (var i = 0; i < 3; i++) {\n    setTimeout(() => console.log(i), 0);\n}", "option_a": "0 1 2", "option_b": "0 0 0", "option_c": "3 3 3", "option_d": "undefined undefined undefined", "correct_option": "C"},
    {"question_text": "How would you fix the above code to print 0 1 2?", "option_a": "Use 'const' instead of 'var'", "option_b": "Use setInterval instead", "option_c": "Remove setTimeout", "option_d": "Use 'let' instead of 'var'", "correct_option": "D"},
    {"question_text": "What is the output?\n\nconst person = {\n    name: 'Alice',\n    greet: function() { return `Hi, ${this.name}`; },\n    greetArrow: () => `Hi, ${this.name}`\n};\n\nconsole.log(person.greet());\nconsole.log(person.greetArrow());", "option_a": "Hi, Alice and Hi, undefined", "option_b": "Hi, undefined and Hi, Alice", "option_c": "Hi, Alice and Hi, Alice", "option_d": "Error", "correct_option": "A"},
    {"question_text": "In Express.js, what is the difference between app.use() and app.get()?", "option_a": "app.use() is for static files; app.get() is for dynamic routes", "option_b": "app.use() is for middleware and matches all HTTP methods; app.get() only matches GET requests", "option_c": "They are identical", "option_d": "app.use() is deprecated", "correct_option": "B"},
    {"question_text": "Your Node.js API is experiencing 'callback hell'. What is the BEST modern approach to fix this?", "option_a": "Add more callbacks", "option_b": "Use synchronous functions instead", "option_c": "Use async/await with try-catch blocks", "option_d": "Use deeper nesting for clarity", "correct_option": "C"},
    {"question_text": "Your Node.js server is crashing with 'JavaScript heap out of memory'. What should you do FIRST?", "option_a": "Restart the server more frequently", "option_b": "Switch to Python", "option_c": "Remove all dependencies", "option_d": "Increase heap size with --max-old-space-size and investigate memory leaks", "correct_option": "D"},
    {"question_text": "What is the output?\n\nconsole.log('1');\nsetTimeout(() => console.log('2'), 0);\nPromise.resolve().then(() => console.log('3'));\nconsole.log('4');", "option_a": "1 4 3 2", "option_b": "1 4 2 3", "option_c": "4 1 3 2", "option_d": "1 2 3 4", "correct_option": "A"},
    {"question_text": "Which of the following is NOT a valid way to handle errors in async functions?", "option_a": ".catch() on the returned promise", "option_b": "Using throw inside a .then() callback without .catch()", "option_c": "Using process.on('unhandledRejection')", "option_d": "try-catch block inside the async function", "correct_option": "B"},
    {"question_text": "What is the output?\n\nconst sym1 = Symbol('foo');\nconst sym2 = Symbol('foo');\nconsole.log(sym1 === sym2);\nconsole.log(sym1.toString());", "option_a": "true Symbol(foo)", "option_b": "true foo", "option_c": "false Symbol(foo)", "option_d": "false foo", "correct_option": "C"},
    {"question_text": "What is the output?\n\nclass Animal {\n    constructor(name) { this.name = name; }\n    speak() { return `${this.name} makes a sound`; }\n}\n\nclass Dog extends Animal {\n    speak() { return `${this.name} barks`; }\n}\n\nconst d = new Dog('Rex');\nconsole.log(d.speak());\nconsole.log(d instanceof Animal);", "option_a": "Error", "option_b": "Rex barks false", "option_c": "Rex makes a sound true", "option_d": "Rex barks true", "correct_option": "D"},
    {"question_text": "What is the output?\n\nconst proxy = new Proxy({}, {\n    get: (target, prop) => prop in target ? target[prop] : 42\n});\n\nproxy.name = 'test';\nconsole.log(proxy.name);\nconsole.log(proxy.nonExistent);", "option_a": "test 42", "option_b": "Error", "option_c": "42 42", "option_d": "test undefined", "correct_option": "A"},
    {"question_text": "In Node.js, what is the difference between require() and import?", "option_a": "require() is faster", "option_b": "require() is synchronous (CommonJS); import is asynchronous and static (ES Modules)", "option_c": "They are identical", "option_d": "import is for CSS files; require is for JS files", "correct_option": "B"},
    {"question_text": "What is the purpose of the package-lock.json file?", "option_a": "It speeds up npm install by caching", "option_b": "It is a backup of package.json", "option_c": "It locks exact dependency versions and their sub-dependencies for reproducible builds", "option_d": "It stores user authentication tokens", "correct_option": "C"},
    {"question_text": "What is the output?\n\nconst arr = [1, 2, 3];\nconst [a, , b] = arr;\nconsole.log(a, b);", "option_a": "2 3", "option_b": "1 2", "option_c": "Error", "option_d": "1 3", "correct_option": "D"},
    {"question_text": "Which HTTP status code should a REST API return when a resource is created successfully?", "option_a": "201 Created", "option_b": "204 No Content", "option_c": "202 Accepted", "option_d": "200 OK", "correct_option": "A"},
    {"question_text": "What is the output?\n\nconst obj = Object.freeze({ a: 1, b: { c: 2 } });\nobj.a = 10;\nobj.b.c = 20;\nconsole.log(obj.a, obj.b.c);", "option_a": "1 2", "option_b": "1 20", "option_c": "Error", "option_d": "10 20", "correct_option": "B"},
    {"question_text": "What is the output?\n\nconsole.log(0 == false);\nconsole.log(0 === false);\nconsole.log('' == false);\nconsole.log('' === false);", "option_a": "true true false false", "option_b": "false false false false", "option_c": "true false true false", "option_d": "true true true true", "correct_option": "C"},
    {"question_text": "What is the output?\n\nfunction* generator() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nconst gen = generator();\nconsole.log(gen.next());\nconsole.log(gen.next());\nconsole.log(gen.return(5));\nconsole.log(gen.next());", "option_a": "{value:1,done:false} {value:2,done:false} {value:3,done:false} {value:5,done:true}", "option_b": "Error", "option_c": "1 2 5 undefined", "option_d": "{value:1,done:false} {value:2,done:false} {value:5,done:true} {value:undefined,done:true}", "correct_option": "D"},
    {"question_text": "In Express.js middleware, what does next() do?", "option_a": "Passes control to the next middleware function in the stack", "option_b": "Closes the connection", "option_c": "Restarts the request handling", "option_d": "Sends the response to the client", "correct_option": "A"},
    {"question_text": "What is the purpose of the 'cluster' module in Node.js?", "option_a": "It groups related modules together", "option_b": "It allows creating child processes that share the same server port, utilizing multiple CPU cores", "option_c": "It handles WebSocket connections", "option_d": "It provides database clustering", "correct_option": "B"},
    {"question_text": "What is the output?\n\nconst weakMap = new WeakMap();\nlet obj = { name: 'test' };\nweakMap.set(obj, 'value');\nobj = null;\n// After garbage collection\nconsole.log(weakMap.has(obj));", "option_a": "Error", "option_b": "true", "option_c": "false", "option_d": "undefined", "correct_option": "C"},
    {"question_text": "What is the output?\n\nconsole.log(NaN === NaN);\nconsole.log(Number.isNaN(NaN));\nconsole.log(isNaN('hello'));\nconsole.log(Number.isNaN('hello'));", "option_a": "true true true true", "option_b": "false true false false", "option_c": "false false false false", "option_d": "false true true false", "correct_option": "D"},
    {"question_text": "What is the output?\n\nconst p = Promise.reject('error');\np.catch(e => console.log('caught:', e))\n .then(() => console.log('then'))\n .catch(() => console.log('catch again'));", "option_a": "caught: error then", "option_b": "caught: error", "option_c": "Error - unhandled rejection", "option_d": "catch again", "correct_option": "A"},
    {"question_text": "What is the output?\n\nconst arr = [3, 1, 4, 1, 5];\nconst sorted = arr.sort();\nconsole.log(arr === sorted);\nconsole.log(arr);", "option_a": "false [1, 1, 3, 4, 5]", "option_b": "true [1, 1, 3, 4, 5]", "option_c": "false [3, 1, 4, 1, 5]", "option_d": "true [3, 1, 4, 1, 5]", "correct_option": "B"},
    {"question_text": "What is the output?\n\nconsole.log(+'');\nconsole.log(+true);\nconsole.log(+null);\nconsole.log(+undefined);", "option_a": "0 1 0 0", "option_b": "'' true null undefined", "option_c": "0 1 0 NaN", "option_d": "NaN NaN NaN NaN", "correct_option": "C"},
    {"question_text": "In a production Node.js application, which tool would you use for process management and automatic restarts?", "option_a": "babel", "option_b": "nodemon", "option_c": "webpack", "option_d": "PM2", "correct_option": "D"},
    {"question_text": "What is the output?\n\nconst a = [1, 2, 3];\nconst b = [1, 2, 3];\nconst c = '1,2,3';\n\nconsole.log(a == c);\nconsole.log(a == b);", "option_a": "true false", "option_b": "false false", "option_c": "false true", "option_d": "true true", "correct_option": "A"},
    {"question_text": "What is the output?\n\nconst obj = {};\nObject.defineProperty(obj, 'x', {\n    value: 42,\n    writable: false,\n    enumerable: false\n});\n\nobj.x = 100;\nconsole.log(obj.x);\nconsole.log(Object.keys(obj));", "option_a": "100 ['x']", "option_b": "42 []", "option_c": "42 ['x']", "option_d": "Error", "correct_option": "B"},
    {"question_text": "What is the difference between null and undefined in JavaScript?", "option_a": "null is for objects; undefined is for primitives", "option_b": "null is falsy; undefined is truthy", "option_c": "undefined means a variable is declared but not assigned; null is an intentional assignment of 'no value'", "option_d": "They are identical", "correct_option": "C"},
    {"question_text": "What is the output?\n\nasync function test() {\n    try {\n        await Promise.reject('error');\n        console.log('after reject');\n    } catch(e) {\n        console.log('caught:', e);\n    }\n    console.log('done');\n}\ntest();", "option_a": "after reject done", "option_b": "caught: error", "option_c": "Error", "option_d": "caught: error done", "correct_option": "D"},
    {"question_text": "What is the output?\n\nconst set = new Set([1, 2, 3, 2, 1]);\nconsole.log(set.size);\nconsole.log([...set]);", "option_a": "3 [1, 2, 3]", "option_b": "2 [1, 2]", "option_c": "5 [1, 2, 3, 2, 1]", "option_d": "Error", "correct_option": "A"},
    {"question_text": "What is the output?\n\nconsole.log(2 ** 3);\nconsole.log(typeof 2 ** 3);", "option_a": "8 string", "option_b": "Error - operator precedence issue", "option_c": "6 number", "option_d": "8 number", "correct_option": "B"},
    {"question_text": "What is the purpose of the AbortController in Node.js/Browser APIs?", "option_a": "To abort database transactions", "option_b": "To stop event listeners", "option_c": "To cancel ongoing asynchronous operations like fetch requests", "option_d": "To abort the Node.js process", "correct_option": "C"},
]
