PYTHON_QUESTIONS = [
    # --- Tricky Concept Questions ---
    {"question_text": "What is the output?\n\na = [1, 2, 3]\nb = a\nb.append(4)\nprint(a)", "option_a": "[1, 2, 3]", "option_b": "[1, 2, 3, 4]", "option_c": "Error", "option_d": "[4, 1, 2, 3]", "correct_option": "B"},
    {"question_text": "What is the output?\n\ndef func(a, b=[]):\n    b.append(a)\n    return b\n\nprint(func(1))\nprint(func(2))", "option_a": "[1] and [2]", "option_b": "[1] and [1, 2]", "option_c": "[1, 2] and [1, 2]", "option_d": "Error", "correct_option": "B"},
    {"question_text": "What is the output?\n\nx = (1,)\ny = (1)\nprint(type(x), type(y))", "option_a": "<class 'tuple'> <class 'tuple'>", "option_b": "<class 'tuple'> <class 'int'>", "option_c": "<class 'int'> <class 'tuple'>", "option_d": "<class 'list'> <class 'int'>", "correct_option": "B"},
    {"question_text": "What is the output?\n\nprint(0.1 + 0.2 == 0.3)\nprint(round(0.1 + 0.2, 1) == 0.3)", "option_a": "True True", "option_b": "False True", "option_c": "True False", "option_d": "False False", "correct_option": "B"},
    {"question_text": "What is the output?\n\na = [1, 2, 3, 4, 5]\nb = a[::2]\nprint(b)", "option_a": "[2, 4]", "option_b": "[1, 3, 5]", "option_c": "[1, 2]", "option_d": "[5, 3, 1]", "correct_option": "B"},
    {"question_text": "What is the output?\n\ndef foo():\n    try:\n        return 1\n    finally:\n        return 2\n\nprint(foo())", "option_a": "1", "option_b": "2", "option_c": "Error", "option_d": "None", "correct_option": "B"},
    {"question_text": "What is the output?\n\nclass A:\n    x = 1\n\nclass B(A):\n    pass\n\nclass C(A):\n    pass\n\nB.x = 2\nprint(A.x, B.x, C.x)", "option_a": "1 1 1", "option_b": "2 2 2", "option_c": "1 2 1", "option_d": "1 2 2", "correct_option": "C"},
    {"question_text": "What is the output?\n\nprint(bool(''))\nprint(bool(' '))\nprint(bool([]))\nprint(bool([0]))", "option_a": "False False False False", "option_b": "False True False True", "option_c": "False False False True", "option_d": "True True False True", "correct_option": "B"},
    {"question_text": "What is the output?\n\na = {1, 2, 3}\nb = {2, 3, 4}\nprint(a & b)\nprint(a | b)\nprint(a - b)", "option_a": "{2, 3} {1, 2, 3, 4} {1}", "option_b": "{1} {1, 2, 3, 4} {2, 3}", "option_c": "Error", "option_d": "{2, 3} {1, 4} {1}", "correct_option": "A"},
    {"question_text": "What does the 'yield' keyword do in Python?", "option_a": "Terminates the function and returns a value", "option_b": "Pauses the function, returning a value, and resumes from the same point on next call", "option_c": "Creates a new thread for the function", "option_d": "Makes the function run asynchronously", "correct_option": "B"},
    # --- Coding Snippet Questions ---
    {"question_text": "What is the output?\n\nfrom collections import Counter\nwords = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']\nc = Counter(words)\nprint(c.most_common(2))", "option_a": "[('apple', 3), ('banana', 2)]", "option_b": "[('banana', 2), ('apple', 3)]", "option_c": "[('cherry', 1), ('banana', 2)]", "option_d": "{'apple': 3, 'banana': 2}", "correct_option": "A"},
    {"question_text": "What is the output?\n\nresult = [x**2 for x in range(10) if x % 2 == 0]\nprint(result)", "option_a": "[0, 4, 16, 36, 64]", "option_b": "[1, 9, 25, 49, 81]", "option_c": "[0, 2, 4, 6, 8]", "option_d": "[4, 16, 36, 64]", "correct_option": "A"},
    {"question_text": "What is the output?\n\ndef decorator(func):\n    def wrapper(*args, **kwargs):\n        print('Before')\n        result = func(*args, **kwargs)\n        print('After')\n        return result\n    return wrapper\n\n@decorator\ndef say_hello():\n    print('Hello')\n\nsay_hello()", "option_a": "Hello", "option_b": "Before Hello After", "option_c": "Before After Hello", "option_d": "Hello Before After", "correct_option": "B"},
    {"question_text": "What is the output?\n\nprint([i for i in range(5) for j in range(i)])", "option_a": "[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]", "option_b": "[0, 1, 2, 3, 4]", "option_c": "[0, 0, 1, 0, 1, 2, 0, 1, 2, 3]", "option_d": "Error", "correct_option": "A"},
    {"question_text": "What is the output?\n\nclass Meta(type):\n    def __new__(cls, name, bases, attrs):\n        attrs['greeting'] = 'Hello'\n        return super().__new__(cls, name, bases, attrs)\n\nclass MyClass(metaclass=Meta):\n    pass\n\nprint(MyClass.greeting)", "option_a": "Error - greeting not defined", "option_b": "Hello", "option_c": "None", "option_d": "AttributeError", "correct_option": "B"},
    {"question_text": "What is the output?\n\nimport asyncio\n\nasync def main():\n    await asyncio.sleep(0)\n    return 42\n\nresult = asyncio.run(main())\nprint(result)", "option_a": "None", "option_b": "42", "option_c": "<coroutine object>", "option_d": "Error", "correct_option": "B"},
    {"question_text": "What is the output?\n\nd = {'a': 1, 'b': 2, 'c': 3}\nresult = {v: k for k, v in d.items()}\nprint(result)", "option_a": "{'a': 1, 'b': 2, 'c': 3}", "option_b": "{1: 'a', 2: 'b', 3: 'c'}", "option_c": "Error", "option_d": "{'c': 3, 'b': 2, 'a': 1}", "correct_option": "B"},
    {"question_text": "What is the output?\n\ndef gen():\n    yield 1\n    yield 2\n    yield 3\n\ng = gen()\nprint(next(g))\nprint(next(g))\nprint(list(g))", "option_a": "1 2 [3]", "option_b": "1 2 [1, 2, 3]", "option_c": "1 2 []", "option_d": "Error", "correct_option": "A"},
    # --- Scenario-Based Questions ---
    {"question_text": "You need to process a 50GB CSV file in Python. What approach would you use?", "option_a": "pd.read_csv('file.csv') to load everything at once", "option_b": "Use pd.read_csv() with chunksize parameter to process in batches", "option_c": "Convert to Excel first then read", "option_d": "Use json.load() to parse it", "correct_option": "B"},
    {"question_text": "In Django, what is the purpose of select_related() vs prefetch_related()?", "option_a": "select_related uses JOIN for ForeignKey/OneToOne; prefetch_related does separate queries for ManyToMany", "option_b": "They are identical in behavior", "option_c": "select_related is for ManyToMany; prefetch_related is for ForeignKey", "option_d": "select_related caches results; prefetch_related doesn't", "correct_option": "A"},
    {"question_text": "What is the GIL (Global Interpreter Lock) in Python?", "option_a": "A threading library for parallel execution", "option_b": "A mutex that allows only one thread to execute Python bytecode at a time", "option_c": "A garbage collection mechanism", "option_d": "A security feature that prevents code injection", "correct_option": "B"},
    {"question_text": "Which approach bypasses the GIL for CPU-bound tasks?", "option_a": "Using threading module", "option_b": "Using asyncio", "option_c": "Using multiprocessing module", "option_d": "Using time.sleep()", "correct_option": "C"},
    {"question_text": "What is the output?\n\nx = 10\ndef outer():\n    x = 20\n    def inner():\n        nonlocal x\n        x = 30\n    inner()\n    print(x)\nouter()\nprint(x)", "option_a": "30 10", "option_b": "20 10", "option_c": "30 30", "option_d": "20 30", "correct_option": "A"},
    {"question_text": "What is the output?\n\nprint(type(lambda: None))", "option_a": "<class 'lambda'>", "option_b": "<class 'function'>", "option_c": "<class 'NoneType'>", "option_d": "Error", "correct_option": "B"},
    {"question_text": "What is the output?\n\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\nprint(fib(10))", "option_a": "34", "option_b": "55", "option_c": "89", "option_d": "Error - recursion limit", "correct_option": "B"},
    {"question_text": "In Python, what is a context manager and which dunder methods does it use?", "option_a": "__init__ and __del__", "option_b": "__enter__ and __exit__", "option_c": "__start__ and __stop__", "option_d": "__open__ and __close__", "correct_option": "B"},
    {"question_text": "What is the output?\n\na = [1, [2, 3], 4]\nimport copy\nb = copy.copy(a)\nb[1].append(5)\nprint(a)", "option_a": "[1, [2, 3], 4]", "option_b": "[1, [2, 3, 5], 4]", "option_c": "[1, [2, 3], 4, 5]", "option_d": "Error", "correct_option": "B"},
    {"question_text": "What is the output?\n\nclass Singleton:\n    _instance = None\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\na = Singleton()\nb = Singleton()\nprint(a is b)", "option_a": "True", "option_b": "False", "option_c": "Error", "option_d": "None", "correct_option": "A"},
    {"question_text": "What is the output?\n\nprint('hello'[::-1])", "option_a": "hello", "option_b": "olleh", "option_c": "h", "option_d": "Error", "correct_option": "B"},
    {"question_text": "What is the output?\n\nimport threading\ncounter = 0\ndef increment():\n    global counter\n    for _ in range(100000):\n        counter += 1\n\nt1 = threading.Thread(target=increment)\nt2 = threading.Thread(target=increment)\nt1.start(); t2.start()\nt1.join(); t2.join()\nprint(counter == 200000)", "option_a": "Always True", "option_b": "Always False", "option_c": "Not guaranteed - could be True or False due to race condition", "option_d": "Error - threads can't access globals", "correct_option": "C"},
    {"question_text": "What is the output?\n\nprint(list(zip([1,2,3], ['a','b'])))", "option_a": "[(1, 'a'), (2, 'b'), (3, None)]", "option_b": "[(1, 'a'), (2, 'b')]", "option_c": "Error", "option_d": "[(1, 'a'), (2, 'b'), (3,)]", "correct_option": "B"},
    {"question_text": "In Flask, what is the purpose of the application context vs request context?", "option_a": "They are the same thing", "option_b": "App context holds app-level data (current_app, g); request context holds request-specific data (request, session)", "option_c": "App context is for production; request context is for testing", "option_d": "App context handles routing; request context handles templates", "correct_option": "B"},
    {"question_text": "What is the output?\n\nprint({True: 'yes', 1: 'no', 1.0: 'maybe'})", "option_a": "{True: 'yes', 1: 'no', 1.0: 'maybe'}", "option_b": "{True: 'maybe'}", "option_c": "{1: 'maybe'}", "option_d": "Error - duplicate keys", "correct_option": "B"},
    {"question_text": "Which Python data structure would you use for an LRU cache?", "option_a": "dict (regular dictionary)", "option_b": "collections.OrderedDict or functools.lru_cache", "option_c": "list", "option_d": "set", "correct_option": "B"},
    {"question_text": "What is the output?\n\nclass MyList(list):\n    def __getitem__(self, index):\n        return super().__getitem__(index) * 2\n\nm = MyList([1, 2, 3])\nprint(m[1])", "option_a": "2", "option_b": "4", "option_c": "[1, 2, 3, 1, 2, 3]", "option_d": "Error", "correct_option": "B"},
    {"question_text": "What does *args and **kwargs do in a function definition?", "option_a": "*args captures keyword arguments as dict; **kwargs captures positional as tuple", "option_b": "*args captures positional arguments as tuple; **kwargs captures keyword arguments as dict", "option_c": "Both capture all arguments as lists", "option_d": "They are decorators", "correct_option": "B"},
    {"question_text": "What is the output?\n\ntry:\n    raise ValueError('error')\nexcept ValueError as e:\n    print(type(e).__name__)\nexcept Exception:\n    print('Exception')\nelse:\n    print('No error')\nfinally:\n    print('Done')", "option_a": "ValueError Done", "option_b": "ValueError Exception Done", "option_c": "ValueError No error Done", "option_d": "Exception Done", "correct_option": "A"},
    {"question_text": "What is the difference between __str__ and __repr__ in Python?", "option_a": "__str__ is for developers; __repr__ is for end users", "option_b": "__str__ is for end-user readable output; __repr__ is for unambiguous developer representation", "option_c": "They are identical", "option_d": "__str__ is called by print(); __repr__ is never called automatically", "correct_option": "B"},
    {"question_text": "What is the output?\n\nfrom dataclasses import dataclass\n\n@dataclass\nclass Point:\n    x: int\n    y: int\n\np1 = Point(1, 2)\np2 = Point(1, 2)\nprint(p1 == p2)\nprint(p1 is p2)", "option_a": "True True", "option_b": "True False", "option_c": "False False", "option_d": "False True", "correct_option": "B"},
    {"question_text": "What is the output?\n\nprint(all([]))\nprint(any([]))\nprint(all([1, 2, 3]))\nprint(any([0, '', None, 1]))", "option_a": "True False True True", "option_b": "False False True True", "option_c": "True True True True", "option_d": "False True True False", "correct_option": "A"},
    {"question_text": "What is the output?\n\nmatrix = [[0]*3 for _ in range(3)]\nmatrix[0][0] = 1\nprint(matrix)", "option_a": "[[1, 0, 0], [1, 0, 0], [1, 0, 0]]", "option_b": "[[1, 0, 0], [0, 0, 0], [0, 0, 0]]", "option_c": "[[1, 1, 1], [0, 0, 0], [0, 0, 0]]", "option_d": "Error", "correct_option": "B"},
    {"question_text": "Versus the list comprehension above, what would happen with:\n\nmatrix = [[0]*3]*3\nmatrix[0][0] = 1\nprint(matrix)", "option_a": "[[1, 0, 0], [0, 0, 0], [0, 0, 0]]", "option_b": "[[1, 0, 0], [1, 0, 0], [1, 0, 0]]", "option_c": "Error", "option_d": "[[1, 1, 1], [1, 1, 1], [1, 1, 1]]", "correct_option": "B"},
    {"question_text": "In Python, what is the Method Resolution Order (MRO)?", "option_a": "The order in which methods are defined in a class", "option_b": "The order Python searches classes in an inheritance hierarchy using C3 linearization", "option_c": "The order methods are called at runtime", "option_d": "The order of method decorators", "correct_option": "B"},
    {"question_text": "What is the output?\n\na = 256\nb = 256\nc = 257\nd = 257\nprint(a is b)\nprint(c is d)", "option_a": "True True", "option_b": "True False", "option_c": "False True", "option_d": "False False", "correct_option": "B"},
    {"question_text": "What is a Python descriptor and where is it commonly used?", "option_a": "A class that defines __get__, __set__, or __delete__; used by property(), classmethod, staticmethod", "option_b": "A function that describes another function", "option_c": "A string that documents a class", "option_d": "A type hint annotation", "correct_option": "A"},
    {"question_text": "What is the output?\n\nfrom itertools import chain\nresult = list(chain([1, 2], [3, 4], [5]))\nprint(result)", "option_a": "[[1, 2], [3, 4], [5]]", "option_b": "[1, 2, 3, 4, 5]", "option_c": "Error", "option_d": "[(1, 3, 5), (2, 4)]", "correct_option": "B"},
]
