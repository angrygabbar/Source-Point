{% extends "layout.html" %}
{% block title %}Messages{% endblock %}
{% block content %}
<div class="h-[calc(100vh-12rem)] bg-white/5 dark:bg-gray-800/20 rounded-lg shadow-xl backdrop-blur-sm border border-white/10 flex animate-dynamic overflow-hidden">
    <div id="contact-list" class="w-full md:w-1/3 border-r border-white/10">
        <div class="p-4 border-b border-white/10">
            <h1 class="text-xl font-bold text-white">Contacts</h1>
        </div>
        <ul class="overflow-y-auto h-[calc(100%-4.5rem)]">
            {% for user in messageable_users %}
                <li class="p-4 hover:bg-white/10 cursor-pointer flex items-center space-x-3 user-contact" data-user-id="{{ user.id }}" data-username="{{ user.username }}">
                    <img src="{{ user.avatar_url }}" alt="Avatar" class="w-10 h-10 rounded-full">
                    <div>
                        <p class="font-semibold text-white">{{ user.username }}</p>
                        <p class="text-sm text-gray-400">{{ user.role.title() }}</p>
                    </div>
                </li>
            {% endfor %}
        </ul>
    </div>

    <div id="chat-window" class="w-full md:w-2/3 flex-col hidden md:flex">
        <div id="chat-header" class="p-4 border-b border-white/10 flex items-center justify-between">
            <div class="flex items-center">
                <button id="back-to-contacts" class="md:hidden mr-4 text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg>
                </button>
                <h2 id="chat-with-username" class="text-xl font-bold text-white">Select a contact to start chatting</h2>
            </div>
            <button id="refresh-chat-button" class="hidden px-3 py-1 rounded-md text-white bg-blue-600 hover:bg-blue-700">
                <i class="fas fa-sync-alt"></i>
            </button>
        </div>

        <div id="message-area" class="flex-1 p-6 overflow-y-auto space-y-4">
            <p id="no-chat-selected" class="text-gray-400 text-center mt-10">Your conversation will appear here.</p>
        </div>

        <div id="message-form-container" class="p-4 border-t border-white/10 hidden">
            <form id="message-form" class="flex items-center space-x-3">
                <input type="hidden" id="recipient-id-input" name="recipient_id">
                <input type="text" id="message-body-input" name="body" class="w-full px-3 py-2 border border-gray-600 rounded-md bg-gray-700/50 text-white placeholder-gray-400" placeholder="Type your message..." autocomplete="off">
                <button type="submit" class="px-4 py-2 rounded-md text-white bg-indigo-600 hover:bg-indigo-700">Send</button>
            </form>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const contactList = document.getElementById('contact-list');
    const chatWindow = document.getElementById('chat-window');
    const userContacts = document.querySelectorAll('.user-contact');
    const backButton = document.getElementById('back-to-contacts');
    const refreshButton = document.getElementById('refresh-chat-button');
    
    const chatHeader = document.getElementById('chat-header');
    const chatUsername = document.getElementById('chat-with-username');
    const messageArea = document.getElementById('message-area');
    const noChatSelected = document.getElementById('no-chat-selected');
    const messageFormContainer = document.getElementById('message-form-container');
    const messageForm = document.getElementById('message-form');
    const recipientIdInput = document.getElementById('recipient-id-input');
    const messageBodyInput = document.getElementById('message-body-input');
    const currentUserId = {{ current_user.id }};
    let activeChatUserId = null;

    function showChatWindow() {
        contactList.classList.add('hidden');
        contactList.classList.remove('md:block');
        chatWindow.classList.remove('hidden');
        chatWindow.classList.add('flex');
    }

    function showContactList() {
        contactList.classList.remove('hidden');
        contactList.classList.add('md:block');
        chatWindow.classList.add('hidden');
        chatWindow.classList.remove('flex');
    }

    // UPDATED: Function to fetch and display the conversation
    async function fetchAndDisplayConversation(userId) {
        messageArea.innerHTML = '<p class="text-gray-400">Loading conversation...</p>';
        try {
            const response = await fetch(`/get_conversation/${userId}`);
            const conversation = await response.json();
            
            messageArea.innerHTML = '';
            if (conversation.length === 0) {
                messageArea.innerHTML = '<p class="text-gray-400 text-center">No messages yet. Start the conversation!</p>';
            } else {
                conversation.forEach(msg => {
                    const messageElement = document.createElement('div');
                    const isSender = msg.sender_id === currentUserId;
                    
                    // This is the core change: apply classes based on who the sender is
                    messageElement.className = `flex mb-4 ${isSender ? 'justify-end' : 'justify-start'}`;
                    
                    messageElement.innerHTML = `
                        <div>
                            <div class="px-4 py-2 rounded-lg ${isSender ? 'bg-indigo-500 text-white' : 'bg-gray-700 text-gray-200'}">
                                <p>${msg.body}</p>
                            </div>
                            <p class="text-xs mt-1 ${isSender ? 'text-right text-gray-500' : 'text-left text-gray-500'}">${msg.timestamp}</p>
                        </div>
                    `;
                    messageArea.appendChild(messageElement);
                });
            }
            messageArea.scrollTop = messageArea.scrollHeight;
        } catch (error) {
            messageArea.innerHTML = '<p class="text-red-400">Error loading conversation.</p>';
            console.error('Fetch error:', error);
        }
    }

    userContacts.forEach(contact => {
        contact.addEventListener('click', () => {
            const userId = contact.dataset.userId;
            const username = contact.dataset.username;
            activeChatUserId = userId;

            if (window.innerWidth < 768) {
                showChatWindow();
            }

            chatUsername.textContent = `Chat with ${username}`;
            noChatSelected.classList.add('hidden');
            messageFormContainer.classList.remove('hidden');
            refreshButton.classList.remove('hidden');
            recipientIdInput.value = userId;
            messageBodyInput.focus();
            
            fetchAndDisplayConversation(userId);
        });
    });

    backButton.addEventListener('click', () => {
        showContactList();
        activeChatUserId = null;
        refreshButton.classList.add('hidden');
    });

    refreshButton.addEventListener('click', () => {
        if (activeChatUserId) {
            fetchAndDisplayConversation(activeChatUserId);
        }
    });

    messageForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const recipientId = recipientIdInput.value;
        const body = messageBodyInput.value;

        if (!recipientId || !body.trim()) return;
        
        const originalInput = messageBodyInput.value;
        messageBodyInput.value = '';

        try {
            const formData = new FormData();
            formData.append('recipient_id', recipientId);
            formData.append('body', body);

            const response = await fetch("{{ url_for('send_message') }}", {
                method: 'POST',
                body: formData,
            });

            // Reload the conversation after sending to show the new message
            fetchAndDisplayConversation(recipientId);

        } catch (error) {
            console.error('Send message error:', error);
            // Optionally, add the message back to the input if sending fails
            messageBodyInput.value = originalInput;
        }
    });
});
</script>
{% endblock %}